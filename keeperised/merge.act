import "arbiter.act";
import "basicGates.act";
import "channels.act";

// L is a previous encoder, R is the output, possibly to a further encoder, and D (down) is a local spiking source with a one-bit payload (e.g. a polarised taxel)

export defproc merge(e1of4 L; e1of2 D; e1of4 R)
{
    // Renaming of external variables
    bool le, ld[4], l0, l1, l2, l3;
    L.e = le;
    L.d = ld;
    L.d[0] = l0;
    L.d[1] = l1;
    L.d[2] = l2;
    L.d[3] = l3;

    bool de, dd[2], d0, d1;
    D.e = de;
    D.d = dd;
    D.d[0] = d0;
    D.d[1] = d1;

    bool re, rd[4], r0, r1, r2, r3;
    R.e = re;
    R.d = rd;
    R.d[0] = r0;
    R.d[1] = r1;
    R.d[2] = r2;
    R.d[3] = r3;

    bool rst, _rst;
    rst = Reset;

    // Validation of D and L
    bool dv, lv, _lv; // v = validated
    or orVd(dd, dv);
    or4 orLv(ld, lv);
    inv invLv(lv, _lv);

    bool ls, _ls, lsi; // ls = L Serial; lsi: I = Internal, i.e. a pre-signal to do with the keeper

    // Arbitration between L and D
    bool dva; // D Valid Arbitrated
    bool lsa, _lsa; // L Serial Arbitrated
    bool ly; // lv and lsa
    longArbiter arb(ls, dv, lsa, dva);
    inv invLsa(lsa, _lsa);
    norx norLy(_lv, _lsa, ly);

    bool  enl,  enf,  end; // en = enable; L = L; F = Final; D = D
    bool _enl, _enf, _end;
    bool enli, _enli; // i = internal
    bool endi, _endi;
    bool enfi, _enfi;
    bool enfii, _enfii; // ii is a second internal variable
    bool _r0, _r1, _r2, _r3;

    // Validation on R
    bool rv, _rv, _rvii, rvi;
    nor4 norRv(rd, _rv);

    prs {
		rst => _rst-
	
		// Introducing an extra guard in rv to check that all _en... have lowered - it's possible to avoid rvi, but I'm leaving it here following a rule of thumb ...
        ~_enl & ~_enf & ~_end & ~_rv									-> rvi+
                                 _rv                          			-> rvi-
        rvi => _rvii- 
        _rvii => rv-

        // main handshake
        (~enl | ~enf | ~end)          & ~re | ~_rst    					-> _r0+
          enl &  enf &  end & ly & l0 &  re			 					-> _r0-
        _r0 => r0-
		// no serial resets in merge - this is okay providing they are in inc and in any spiking sources (d).

        (~enl | ~enf | ~end) 		  & ~re | ~_rst    					-> _r1+
          enl &  enf &  end & ly & l1 &  re								-> _r1-
        _r1 => r1-
		
        (~enl | ~enf | ~end)                            & ~re | ~_rst 	-> _r2+
          enl &  enf &  end & ((ly & l2) | (dva &  d0)) &  re			-> _r2-
        _r2 => r2-

        (~enl | ~enf | ~end)                            & ~re | ~_rst   -> _r3+
		  enl &  enf &  end & ((ly & l3) | (dva &  d1)) &  re		 	-> _r3-
        _r3 => r3-

		// It's possible to not have enli, but rather just have enl and _enl, without it glitching; I'm leaving this extra stage here as a rule of thumb
              ~ly             & ~rv | ~_rst                				-> enli+
        end &  ly & (l0 | l1) &  rv			 							-> enli-
        enli => _enli-
        _enli => enl-
        enl => _enl-

		// It's possible to not have enfi or enfii, but rather just have enf and _enf, without it glitching; I'm leaving this extra stage here as a rule of thumb
              ~ly & ~ls & ~lsa & ~lv & ~rv | ~_rst 						-> enfi+
        end &  ly & (l2 | l3)        &  rv			       				-> enfi-
        enfi => _enfi-
        _enfi => enf-

        ~enf       														-> _enfii+
        enf & _lsa 														-> _enfii- //additional finishing conditions
        _enfii => enfii-
        enfii => _enf-

              ~dva & ~rv | ~_rst    									-> endi+
        enf &  dva &  rv												-> endi-
        endi => _endi-
        _endi => end-
        end => _end-
        _end => de-


        ~_enl & ~_enf  | ~_rst 											-> le+
        (_enl |  _enf) &  _rst  										-> le-

        // ls is set when multitoken communication starts on L
               ~_lv & ~rst 												-> lsi+
        _enf &  _lv |  rst 												-> lsi-
        lsi => _ls-
        _ls => ls-

    }
}
